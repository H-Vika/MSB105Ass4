---
title: "Assignment 4:"
subtitle:  "Eu statistikk."
author: "Magnus Eidesmo og Harald Vika"
date: last-modified
date-format: "dddd D MMM, YYYY"
lang: en-GB
format:
  html: default
  typst:
    papersize: a4
  pdf: 
    documentclass: article
    number-sections: true
    keep-tex: true
    papersize: A4
    fig-pos: "H"
abstract: ""
editor: 
  markdown: 
    wrap: sentence
echo: false
---

```{r}
#| label: setup
#| message: false
library(tidyverse)
library(readxl)
library(restatapi)
library(DescTools)
library(ggrepel)
library(flextable)
library(modelr)
library(plm)
library(broom)
library(sandwich)
```

## Toc. eurostat
```{r}
# xml skal ha mer detaljert info
# toc_xml <- get_eurostat_toc()
# tekstversjonen har trolig nok info for vårt formål
toc_txt <- get_eurostat_toc(mode = "txt")
```


## GDP Nuts 3
```{r}
gdp_tabs <- toc_txt |> 
# Regex AND external to regex
   filter(
     str_detect(
       string = title,
       # For å matche både små og store bokstaver
       pattern = '[Gg][Dd][Pp]'
       # AND vha. &
       ) &
     str_detect(
       string = title,
       # For å matche både små og store bokstaver og
       # space eller ikke før 3
       pattern = '[Nn][Uu][Tt][Ss]\\s*3'
       )
     ) |> 
  select(title, code)
```

```{r}
gdp_tabs |> 
  select(title, code) |> 
  flextable()  |> 
  width(1, width = 3.5) |> 
  width(2, width = 1.5)
```


```{r}
# description nama_10r_3gdp
dsd_gdp <- get_eurostat_dsd("nama_10r_3gdp")
```


```{r}
dsd_gdp |> 
  filter(concept %in% c('freq', 'unit')) |> 
  flextable()  |> 
  width(j = 1, width = 1) |> 
  width(j = 2, width = 2) |> 
  width(j = 3, width = 2)
```

```{r}
dsd_gdp |> 
  filter(concept %in% c('geo')) |> 
  head(n = 10) |> 
  flextable()  |> 
  width(j = 1, width = 1) |> 
  width(j = 2, width = 2) |> 
  width(j = 3, width = 2)
```

```{r}
#| eval: true
#| cache: true
# Gross domestic product (GDP) at current market prices by NUTS 3 regions 
# id: nama_10r_3gdp
# Vi velger å hente samtlige soner for så å filtrere ut de få vi ikke trenger
gdp <- get_eurostat_data(
  id = "nama_10r_3gdp",
  filters = list(
    # neste linje viser hvordan vi kunne ha hentet ut data
    # for spesifiserte land
    # geo = c("AT", "DE", "DK", "FR"),
    nuts_level = "3",
    unit = "MIO_PPS_EU27_2020"
  ),
  exact_match = FALSE,
  date_filter = 2000:2023,
  stringsAsFactors = FALSE
  ) |> 
  mutate(
    gdp_n3 = 1000000 * values
  ) |> 
  select(-c(unit, values)) |> 
  # Vil bare ha NUTS 3 nivå (5 karakterer). Vil aggregere selv til NUTS2,
  # NUTS1 og NUTSc  
  filter(str_length(geo) == 5) |> 
  as_tibble()
```


```{r}
dim(gdp)
```

```{r}
gdp
```

```{r}
gdp |> 
  filter(geo == "IE053") |> 
  print(n = 25)
```

```{r}
ie_data <- tibble(
  geo = c("IE053", "IE053", "IE053"),
  time = c("2015", "2016", "2017"),
  gdp_n3 = c(NA, NA, NA)
)
```

```{r}
gdp <- rbind(gdp, ie_data)
```

```{r}
gdp <- gdp |> 
  arrange(geo, time) |> 
  mutate(
    gdp_n3 = zoo::na.approx(gdp_n3)
  )
```

```{r}
gdp |> 
  filter(geo == "IE053") |> 
  print(n = 25)
```

# Population demo_r_pjanaggr3

## oppgave 1
Søker i toc_txt for tabeller
```{r}
pop_tabs <- toc_txt |>
  filter(
    # Matcher både population og Population
    str_detect(
      string = title,
      pattern = "[Pp][Oo][Pp][Uu][Ll][Aa][Tt][Ii][Oo][Nn]"
    ) &
    # Matcher både NUTS3 og NUTS 3
    str_detect(
      string = title,
      pattern = "[Nn][Uu][Tt][Ss]\\s*3"
    )
  ) |>
  select(title, code)


```



## oppgave 2
###(i)
```{r}
pop_tabs |>
  filter(
    str_detect(title, regex("population", ignore_case = TRUE)) &
    str_detect(title, regex("NUTS\\s*3", ignore_case = TRUE))
  )

```

```{r}
pop_tabs |>
  filter(
    str_detect(
      title,
      fixed("Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 region")
    )
  ) |>
  select(code)
```
Finner at koden er demo_r_pjanaggr3 for tabellen med forklarende tekst «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions»

###(ii)
Last ned Data Structure Definition (DSD) for denne tabellen.
```{r}
dsd_pop <- get_eurostat_dsd("demo_r_pjanaggr3")
```

### (iii) (iv) og (v)
Tre av oppgavene i en, laster ned dataen og gi den navnet pop, plukker ut årene fra 2000 til 2023 og den totale befolkningen, begrenser datasettet til NUTS3 regioner og konverterer settet til en tibble.
```{r}
#| eval: true
#| cache: true
pop <- get_eurostat_data(
 id = "nama_10r_3popgdp",
 filters = list(
 nuts_level = "3",
 unit = "THS"
 ),
 exact_match = FALSE,
 date_filter = 2000:2023,
 stringsAsFactors = FALSE
 ) |>
 mutate(
 pop_n3 = values * 1000
 ) |> 
  select(-c(unit, values)) |>
 filter(str_length(geo) == 5) |> 
 as_tibble()
```

```{r}
dim(pop)
```

## Oppgave 3
Slå sammen GDP-data (gdp) og befolkingsdata (pop)
```{r}
gdp_pop <- gdp |>
  left_join(pop, by = c("geo", "time"))
```

Kontrollerer:

```{r}
dim(gdp_pop)
head(gdp_pop)
```

Gjør følgende tilpasning av gdp_pop:
```{r}
eu_data <- gdp_pop %>%
  # Trenger ikke ZZ sonene som er en slag oppsamlingssone
  # for ikke fordelte verdier
  filter(!str_sub(geo, 3, 4) == "ZZ") |> 
  # Drop the EFTA countries Switzerland and Norway
  filter(!str_sub(geo, 1, 2) %in% c("CH", "NO")) |> 
  # Drop the EU countries Netherlands and Portugal
  filter(!str_sub(geo, 1, 2) %in% c("NL", "PT")) |> 
  # Drop candidate country Monte Negro because of data
  filter(!str_sub(geo, 1, 2) %in% c("ME")) |> 
  # Drop a region of France in the Indian Ocean (Outre Mer); Mayotte
  # because of missing data
  filter(!geo == "FRY50") |> 
  # note that a few countries will have missing data for
  # some years at the start of the period
  filter(time > 1999 & time < 2023)
```

Regner ut gdp per capita og gir den et nytt navn:
```{r}
eu_data <- eu_data |>
  mutate(
  gdp_pc_n3 = gdp_n3 / pop_n3
)
```

Kontrollerer:
```{r}
dim(eu_data)
```
Sjekker om vi mangler data for enkelte år for noen soner:

```{r}
dim(
  eu_data |>
    filter(is.na(gdp_pc_n3))
)
```
Var ikke noe mer NA-verdier igjen i gdp_pc_n3
Kvitter oss med andre objekter for å rydde litt ettersom vi bare skal bruke eu_data videre:
```{r}
# don't run if you don't mean it.
rm(list = setdiff(ls(), c("eu_data")))
```


## Oppgave 4
Endrer ny navn på geo til n3 og legger til variablene n2, n1 og nc fra variabelen n3.
```{r}
eu_data <- eu_data |>
  rename(n3 = geo) |>
  mutate(
    n2 = str_sub(n3, 1, 4),
    n1 = str_sub(n3, 1, 3),
    nc = str_sub(n3, 1, 2)
  )

```

## Oppgave 5
Undersøk om vi har noen NUTS 3 soner med pop_n3 lik 0. Hvis det er noen så endre disse til NA.
Undersøker: 
```{r}
eu_data |>
  filter(pop_n3 == 0)
```
Fant ingen rader med 0 og vi går videre, trenger ikke å endre noe til NA.

## Oppgave 6
Sjekker hvor mange NUTS3 soner vi har i hvert land, tar en strukturkontroll:
```{r}
eu_data |>
  select(nc, n3) |> # Henter ut de variablene vi trenger
  distinct() |> # Fjerner duplikater 
  group_by(nc) |> # Grupperer per land
  summarise(
    num_nuts3 = n(),
    .groups = "drop"
  ) |>
  arrange(desc(num_nuts3)) # Gir mest informative oversikt, legger det største landet øverst
```

## Oppgave 7
Sjekker summary for gdp_pc_n3 for å se om hva som er har den største og minste verdien og om det er noen NA:
```{r}
summary(eu_data$gdp_pc_n3)
```

Minste verdien er 2 214, mens max er på 180 416. Får ingen NA.

## Oppgave 8 
Bruk case_when() for å legge til variabelen nc_name før vi går videre. Østerrike for AT, Belgia for BE etc..
```{r}
eu_data <- eu_data |>
  mutate(
    nc_name = case_when(
      nc == "AL" ~ "Albania",
      nc == "AT" ~ "Østerrike",
      nc == "BE" ~ "Belgia",
      nc == "BG" ~ "Bulgaria",
      nc == "CY" ~ "Kypros",
      nc == "CZ" ~ "Tjekkia",
      nc == "DE" ~ "Tyskland",
      nc == "DK" ~ "Danmark",
      nc == "EE" ~ "Estland",
      nc == "EL" ~ "Hellas",
      nc == "ES" ~ "Spania",
      nc == "FI" ~ "Finland",
      nc == "FR" ~ "Frankrike",
      nc == "HR" ~ "Kroatia",
      nc == "HU" ~ "Ungarn",
      nc == "IE" ~ "Irland",
      nc == "IT" ~ "Italia",
      nc == "LT" ~ "Litauen",
      nc == "LU" ~ "Luxemburg",
      nc == "LV" ~ "Latvia",
      nc == "MK" ~ "Nord-Makedonia",
      nc == "MT" ~ "Malta",
      nc == "PL" ~ "Polen",
      nc == "RO" ~ "Romania",
      nc == "RS" ~ "Serbia",
      nc == "SE" ~ "Sverige",
      nc == "SI" ~ "Slovenia",
      nc == "SK" ~ "Slovakia",
      nc == "TR" ~ "Tyrkia",
      TRUE ~ NA_character_
    )
  )

```
Kontrollerer:
```{r}
eu_data |> 
  select(nc_name, nc) |> 
  distinct() |> 
  print(n = 30)
```

# Beregning av Gini på NUTS2, NUTS1 og NUTSc nivå
Vi skal nå beregne Gini for hvert år på NUTS2, NUTS1, NUTSc og EU nivå. Vi vil beregne Gini utfra gdp_pc_n3 og pop_n3 i NUTS3 for alle aggregeringsnivåene.
Gini-koeffisient er tradisjonelt et mål på inntektsforskjeller. Her benytter vi målet for å undersøke hvor jevnt verdiskapningen er fordelt mellom regioner. En Gini-koeffisient nær null vil altså her bety at verdiskapingen er jevnt fordelt mellom regionene i et land. En Gini-koeffisient nær 1 vil det derimot bety at det meste av verdiskapingen i et land er sentralisert til en spesifikk NUTS3 region.

## Gini- koeffisient for NUTS2
## Oppgave 9
Beregner Gini-koeffisienter på NUTS2 nivå:

```{r}
gini_n2 <- eu_data |>
  group_by(n2, time, n1, nc, nc_name) |> 
  summarise(
    gini_n2 = DescTools::Gini(gdp_pc_n3, weights = pop_n3, na.rm = TRUE),
    pop_n2 = sum(pop_n3),
    gdp_n2 = sum(gdp_n3),
    gdp_pc_n2 =  gdp_n2 / pop_n2,
    num_reg_n2 = n(),
    .groups = "drop"
  ) 
```
Kontrollerer:

```{r}
summary(
  gini_n2 |>
    select(gini_n2, num_reg_n2, pop_n2, gdp_n2, gdp_pc_n2)
)
```
Får de samme tallene som kontrollen i oppgaven. Vi ser at vi har et spenn i Gini-koeffisienten på NUTS2 nivå fra 0.0004 til 0.4779. Vi har også 856 NAs. Vi ser også at antall NUTS3 i NUTS2 regioner spenner fra 1 til 23.

## Oppgave 10
Finner observasjoner med Gini < 0.001
```{r}
gini_n2 |>
  filter(gini_n2 < 0.001)
```
Får opp 4 obervasjoner
Se så på kjennetegnet ved disse regionene:
```{r}
gini_n2 |>
  filter(gini_n2 < 0.001) |>
  select(
    nc_name,
    n2,
    time,
    gini_n2,
    num_reg_n2,
    pop_n2,
    gdp_pc_n2
  ) |>
  arrange(num_reg_n2)

```

Det som blir observert her er at de fleste har få NUTS3-regioner i sine NUTS2, noe som gjør at alle NUTS3 regionene er omtrent lik gdp_pc_n3 eller om det bare er en region. Derfor får disse observasjonene en ekstremt lav Gini.

## Oppgave 11
Beregn Gini-koeffsienter på NUTS1-nivå, der gdp_pc_n2 eller pop_n2 ikke skal brukes som grunnlag:
```{r}
gini_n1 <- eu_data |>
  group_by(n1, time, nc, nc_name) |>
  summarise(
    gini_n1 = DescTools::Gini(
      gdp_pc_n3,
      weights = pop_n3,
      na.rm = TRUE
    ),
    pop_n1 = sum(pop_n3),
    gdp_n1 = sum(gdp_n3),
    gdp_pc_n1 = gdp_n1 / pop_n1,
    num_reg_n1 = n(),
    .groups = "drop"
  )

```
Kontrollerer:
```{r}
gini_n1 |>
  select(gini_n1, num_reg_n1, gdp_n1, pop_n1, gdp_pc_n1) |>
  summary() |>
  print(width = 80)

```
Får de samme tallene som oppgaven. Vi ser at vi har et spenn i Gini-koeffisienten på NUTS1 nivå fra 0.016 til 0.429. Antall NAs er nå 177. Vi ser at antall NUTS3 i NUTS1 regioner spenner helt fra 1 til 96.

## Oppgave 12
Beregn Gini-koeffisienter på nasjonsnivå
Måler hvor jevnt verdiskapningen er fordelt mellom regioner innen samme land:
```{r}
gini_nc <- eu_data |>
  group_by(nc, time, nc_name) |>
  summarise(
    gini_nc = DescTools::Gini(
      gdp_pc_n3,
      weights = pop_n3,
      na.rm = TRUE
    ),
    pop_nc = sum(pop_n3),
    gdp_nc = sum(gdp_n3),
    gdp_pc_nc = gdp_nc / pop_nc,
    num_reg_nc = n(),
    .groups = "drop"
  )

```

Kontrollerer 
```{r}
gini_nc |> 
  select(gini_nc, num_reg_nc, gdp_nc, pop_nc, gdp_pc_nc) |> 
  summary() |> 
  print(width = 80)
```
Får samme som oppgaven. På landsnivå varierer Gini fra 0,1111 til 0,3991. Antall NUTS3 regioner per land varierer fra 1 til 400.

# "Nestete" datastrukturer
Vi vil nå «neste» de ulike gini_NUTS* datasettene og sette dem sammen til et nestet datasett eu_data_nestet som innholder alle dataene ovenfor i en fint ordnet struktur.

## Oppgave 13
"neste" dataene på NUTS3 nivå
```{r}
gini_n3_nest <- eu_data |> 
  group_by(nc_name, nc) |> 
  nest(.key = "NUTS3_data") |> 
  ungroup()
```

```{r}
gini_n3_nest
```


## Oppgave 14
«Nest» dataene på NUTS2 nivå. Legg resultatet gini_NUTS2_nest. Bruk .key = "NUTS2_data".
```{r}
gini_n2_nest <- gini_n2 |>
  group_by(nc_name, nc)|>
 nest(.key = "NUTS2_data")
```

## Oppgave 15
«Nest» dataene på NUTS1 nivå. Legg resultatet gini_NUTS1_nest.
```{r}
gini_NUTS1_nest <- gini_n1 |>
  group_by(nc_name, nc) |>
  nest(.key = "NUTS1_data") |>
  ungroup()
```

## Oppgave 16 
«Nest» dataene på nasjonsnivå. Legg resultatet i gini_NUTSc_nest.
```{r}
gini_NUTSc_nest <- gini_nc |>
  group_by(nc_name, nc) |>
  nest(.key = "NUTSc_data") |>
  ungroup()
```

## Oppgave 17
«Nest» dataene på EU nivå, dvs. Gini for samtlige NUTS3 regioner hvert år. Legger resultatet i gini_NUTSeu_nest. _nest er her litt misvisende siden vi ikke gjør noen nesting.

```{r}
gini_NUTSeu_nest <- eu_data |>
  group_by(time) |> 
  summarise(
    gini_eu = DescTools::Gini(gdp_pc_n3, weights = pop_n3, na.rm = TRUE),
    num_reg_eu = n(),
    .groups = "drop"
  ) 
```


